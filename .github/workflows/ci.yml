name: CI

# CI pipeline for stb_unpack.h
# - Builds nob build system
# - Compiles all test programs
# - Runs test suite
# - Fails on compilation errors or test failures
# - Warns (but doesn't fail) on skipped tests

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up build environment (Linux)
      if: matrix.os == 'ubuntu-latest'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential
    
    - name: Set up build environment (Windows)
      if: matrix.os == 'windows-latest'
      shell: bash
      run: |
        # GitHub Windows runners typically have MinGW gcc available
        # Check if gcc is available
        if ! command -v gcc &> /dev/null; then
          echo "::error::gcc not found on Windows runner"
          echo "GitHub Windows runners should have MinGW available."
          exit 1
        fi
        gcc --version
        echo "✓ gcc is available"
    
    - name: Build nob
      shell: bash
      run: |
        echo "::group::Building nob build system"
        if [ "${{ matrix.os }}" == "windows-latest" ]; then
          gcc -o nob.exe nob.c
          if [ ! -f nob.exe ]; then
            echo "::error::Failed to build nob.exe"
            exit 1
          fi
          echo "✓ nob.exe built successfully"
        else
          gcc -o nob nob.c
          if [ ! -f nob ]; then
            echo "::error::Failed to build nob"
            exit 1
          fi
          echo "✓ nob built successfully"
        fi
        echo "::endgroup::"
    
    - name: Build test programs
      shell: bash
      run: |
        echo "::group::Building test programs"
        if [ "${{ matrix.os }}" == "windows-latest" ]; then
          ./nob.exe build
          BUILD_EXIT=$?
        else
          ./nob build
          BUILD_EXIT=$?
        fi
        
        if [ $BUILD_EXIT -ne 0 ]; then
          echo "::error::Build step failed with exit code $BUILD_EXIT"
          exit 1
        fi
        echo "::endgroup::"
    
    - name: Verify test executables were built
      shell: bash
      run: |
        echo "::group::Verifying test executables"
        MISSING=0
        if [ "${{ matrix.os }}" == "windows-latest" ]; then
          for exe in test.exe test_create.exe test_targz.exe test_zip.exe test_runner.exe; do
            if [ ! -f "test/build/$exe" ]; then
              echo "::error::test/build/$exe not found!"
              MISSING=1
            else
              echo "✓ test/build/$exe found"
            fi
          done
        else
          for exe in test test_create test_targz test_zip test_runner; do
            if [ ! -f "test/build/$exe" ]; then
              echo "::error::test/build/$exe not found!"
              MISSING=1
            else
              echo "✓ test/build/$exe found"
            fi
          done
        fi
        
        if [ $MISSING -ne 0 ]; then
          echo "::error::Some test executables are missing"
          exit 1
        fi
        echo "✓ All test executables built successfully"
        echo "::endgroup::"
    
    - name: Run tests
      shell: bash
      id: run_tests
      continue-on-error: true
      run: |
        echo "::group::Running test suite"
        if [ "${{ matrix.os }}" == "windows-latest" ]; then
          ./nob.exe test 2>&1 | tee test_output.txt
        else
          ./nob test 2>&1 | tee test_output.txt
        fi
        TEST_EXIT_CODE=${PIPESTATUS[0]}
        echo "exit_code=$TEST_EXIT_CODE" >> $GITHUB_OUTPUT
        echo "::endgroup::"
    
    - name: Parse test results
      shell: bash
      id: parse_results
      run: |
        echo "::group::Parsing test results"
        # Count test results from output
        if [ -f test_output.txt ]; then
          PASSED=$(grep -c "✓.*PASSED" test_output.txt 2>/dev/null || true)
          FAILED=$(grep -c "✗.*FAILED" test_output.txt 2>/dev/null || true)
          SKIPPED=$(grep -c "⚠.*SKIPPED" test_output.txt 2>/dev/null || true)
        else
          PASSED=0
          FAILED=0
          SKIPPED=0
        fi
        PASSED=${PASSED:-0}
        FAILED=${FAILED:-0}
        SKIPPED=${SKIPPED:-0}
        
        echo "passed=$PASSED" >> $GITHUB_OUTPUT
        echo "failed=$FAILED" >> $GITHUB_OUTPUT
        echo "skipped=$SKIPPED" >> $GITHUB_OUTPUT
        
        echo ""
        echo "=== Test Summary ==="
        echo "Passed: $PASSED"
        echo "Failed: $FAILED"
        echo "Skipped: $SKIPPED"
        echo "==================="
        echo "::endgroup::"
    
    - name: Check test results
      shell: bash
      run: |
        echo "::group::Evaluating test results"
        
        # Check if test runner exited with error
        if [ "${{ steps.run_tests.outputs.exit_code }}" != "0" ]; then
          echo "::error::Test runner exited with code ${{ steps.run_tests.outputs.exit_code }}"
          echo "This usually indicates a compilation error or test execution failure."
          exit 1
        fi
        
        # Check for failed tests
        if [ "${{ steps.parse_results.outputs.failed }}" != "0" ]; then
          echo "::error::${{ steps.parse_results.outputs.failed }} test(s) failed"
          echo "Failed tests indicate a problem with the implementation."
          exit 1
        fi
        
        # Warn about skipped tests (but don't fail)
        if [ "${{ steps.parse_results.outputs.skipped }}" != "0" ]; then
          echo "::warning::${{ steps.parse_results.outputs.skipped }} test(s) were skipped"
          echo "Skipped tests usually mean required external tools (tar, unzip, zip) are not available."
          echo "This is a warning, not a failure."
        fi
        
        # Success message
        echo "✓ All tests passed!"
        echo "Passed: ${{ steps.parse_results.outputs.passed }}"
        if [ "${{ steps.parse_results.outputs.skipped }}" != "0" ]; then
          echo "Skipped: ${{ steps.parse_results.outputs.skipped }} (warning only)"
        fi
        echo "::endgroup::"
    
    - name: Upload test output (on failure)
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: test-output-${{ matrix.os }}
        path: test_output.txt

